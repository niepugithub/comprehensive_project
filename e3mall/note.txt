页面静态化：

	不是改后缀，改后缀是伪静态化
	真的生成html，将html响应给用户就OK了

freemarker 基于模板生成的静态页面的工具包

day9 - 9 sublime操作多行


freemarker页面静态化：html页面直接存在于用户浏览器，如果是jsp的话，每次都要根据jsp重新生成html
添加商品之后，e3-item-web会监听，然后创建对应商品的静态html页面，这个html页面可以放在nginx服务器上
加上静态的js,css样式，就会跟我们直接静态看的是一样的；
这样当用户点击商品查看详细的时候，我们可以将连接链到nginx服务器上，直接响应静态页面，会很快

分布式session分析
tomcat有session共享功能，但是session之间共享会限制集群度，无法通过扩容应对高并发
所以不能用session共享模式，而是将session抽取出来，统一管理；所有的tomcat服务器都不直接
存储session，而使用单独的服务器存储session，所以不用tomcat自己的session而使用我们自己
模拟的session使用redis缓存，session是键值对且有过期时间，与redis如出一辙

将session放入到redis中，那么用什么做key?
不能用userId，比如换电脑了，应该不是同一个session，如果用的userId，多台电脑登录还是一个session，不行！！
session有一个sessionId，通过sessionId区分不同会话，sessionId放在cookie中，下次请求带上sessionId
因此，我们需要模拟sessionId，并且不能重复；自己生成且不重复，使用uuid，也就是token，本质是sessionId
key就是token，一个token对应一个session，一个session对应一个用户信息
value：用户信息

需要将key（token）写入到cookie，下次用户请求会带上



单点登录系统，主要是解决session共享问题


分布式事务：
    跨数据库的事务（oracle，mysql之间跨事务等）很麻烦，效率还很低；
    企业内部可以承受，互联网项目无法承受长时间等待

用户提交订单消息，发送消息给中间件；直接响应给用户；mq实现最终的一致性，实际上并没有直接去使用分布式事务

分布式项目中一般也很少用到分布式锁

登录成功后，页眉上应该显示用户信息，而不是请登录
如何获取到用户信息呢？写在controller中不好，因为每个controller都要写；麻烦
我们写一个js，专门负责根据token获取用户信息；然后每个页面引用这个js；
因此，我们需要sso做一个restAPI，让js调用



